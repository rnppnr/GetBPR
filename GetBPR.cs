using GetBPR.Enums;
using GetBPR.Models;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Azure.WebJobs.Extensions.OpenApi.Core.Attributes;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading.Tasks;

namespace GetBPR
{
    public class GetBPR
    {
        #region variables
        private readonly Random _random = new Random();
        private DateTime _previousTime;
        private byte _readingCounter = 0;

        private readonly ILogger<GetBPR> _logger;
        #endregion

        public GetBPR(ILogger<GetBPR> log)
        {
            _logger = log;
        }

        /// <summary>
        /// Azure Function handles incoming HTTP requests with "get" or "post" methods. It extracts 
        /// query parameters from the request and deserializes the request body to dynamic data. The
        /// function then attempts to parse the parameters into byte values for age, quantity, and risk type.
        /// It performs basic validation on the parsed parameters to check for missing or invalid inputs. 
        /// If the parameters are valid, the function returns an HTTP 200 response (OK) with a list of blood 
        /// pressure readings (BPR) generated using the 'GetOkResponse' method based on the parsed parameters.
        /// If any of the parameters are missing or invalid, the function returns an HTTP 400 response (Bad 
        /// Request) with an error message generated by the 'GetBadResponse' method, indicating the specific 
        /// issues with the input parameters.
        /// </summary>
        /// <param name="req"></param>
        /// <returns>HTTP Response</returns>
        #region swagger
        [FunctionName("GetBPR")]
        [OpenApiOperation(operationId: "Run")]
        [OpenApiParameter(name: "age", In = ParameterLocation.Query, Required = true, Type = typeof(string), Description = "The **Age** parameter")]
        [OpenApiParameter(name: "quantity", In = ParameterLocation.Query, Required = true, Type = typeof(string), Description = "The **Qty** parameter")]
        [OpenApiParameter(name: "risk", In = ParameterLocation.Query, Required = true, Type = typeof(string), Description = "The **Risk** parameter (1,2,3)")]
        [OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: "application/json", bodyType: typeof(Response), Description = "The OK response")]
        #endregion
        public async Task<IActionResult> Run(
            [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post", Route = null)] HttpRequest req)
        {
            // Extract query parameters from the request
            string age  = req.Query["age"];
            string qty  = req.Query["quantity"];
            string risk = req.Query["risk"];

            // Log the incoming request data for debugging or monitoring purposes
            _logger.LogInformation($"Called with Age: {age}, Qty: {qty}, Risk: {risk}");

            // Deserialize the request body to dynamic data
            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
            dynamic data = JsonConvert.DeserializeObject(requestBody);

            // Use query parameters if present, otherwise fallback to data from the request body
            age  = age  ?? data?.age;
            qty  = qty  ?? data?.quantity;
            risk = risk ?? data?.risk;

            // Parse the parameters to byte values
            _ = byte.TryParse(age, out byte personAge);
            _ = byte.TryParse(qty,  out byte noRequired);
            _ = byte.TryParse(risk, out byte riskType);

            bool validParams = ValidateParameters(age, qty, risk);

            // Return an appropriate HTTP response based on the validity of the parameters
            if (validParams)
                return new OkObjectResult(GetOkResponse(personAge, noRequired, riskType));
            else
                return new BadRequestObjectResult(GetBadResponse(personAge, noRequired, riskType));

        }

        /// <summary>
        /// This method validates the input parameters for generating a blood pressure reading. It takes three 
        /// parameters: 'personAge', 'noRequired', and 'riskType', all provided as strings.
        /// The method uses two separate validation functions to ensure the validity of each parameter:
        /// 1. The 'ValidParameterValue' function validates each parameter ('personAge', 'noRequired', and 
        ///    'riskType') to ensure they are not null or empty strings.
        /// 2. The 'ValidRiskType' function is used to validate the 'riskType' parameter to ensure it is a valid 
        ///    risk type value based on the 'RiskType' enumeration.
        /// If all three parameters pass their respective validations, the method returns 'true', indicating that 
        /// the input parameters are valid for generating a blood pressure reading. If any of the parameters fail 
        /// their validations, the method returns 'false', indicating that one or more of the input parameters 
        /// are either null, empty, or not in the correct format for generating a valid blood pressure reading.
        /// </summary>
        /// <param name="personAge"></param>
        /// <param name="noRequired"></param>
        /// <param name="riskType"></param>
        /// <returns></returns>
        private bool ValidateParameters(string personAge, string noRequired, string riskType)
        {
            return
                ValidParameterValue(personAge)  &&
                ValidParameterValue(noRequired) &&
                ValidParameterValue(riskType)   &&
                ValidRiskType(riskType);
        }

        /// <summary>
        /// This method validates a string input representing a parameter value. It attempts to parse the 
        /// 'input' string into a byte using 'byte.TryParse' and stores the parsed value in the 'value' 
        /// variable. The method then performs two validation checks:
        /// 1. The 'input' string must not be null or empty, ensuring it contains a valid parameter value.
        /// 2. The 'value' (parsed from the 'input' string) must be greater than 0, indicating a valid positive 
        ///    parameter value.
        /// If both validation conditions are met, the method returns 'true', indicating that the parameter 
        /// value is valid. Otherwise, it returns 'false', indicating that the 'input' parameter is either null, 
        /// empty, or not a valid positive parameter value.        
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private bool ValidParameterValue(string input)
        {
            _ = byte.TryParse(input, out byte value);
            
            return
                !string.IsNullOrEmpty(input) &&
                value > 0;

        }

        /// <summary>
        /// This method validates a string input representing a risk type. It takes a single parameter, 'input', 
        /// which is the risk type as a string. The method first attempts to parse the 'input' string into a 
        /// byte using 'byte.TryParse', and stores the parsed value in the 'risk' variable. 
        /// The method then performs two validation checks:
        /// 1. The 'input' string must be a valid parameter value based on the 'ValidParameterValue' method, 
        ///    which likely checks for null or non-empty strings.
        /// 2. The 'risk' value (parsed from the 'input' string) must fall within the valid range of the 
        ///    'RiskType' enumeration, specifically between the 'Normal' and 'High' enum values.
        /// If both validation conditions are met, the method returns 'true', indicating that the risk type is 
        /// valid. Otherwise, it returns 'false', indicating that the input parameter 'input' is either null, 
        /// empty, or not a valid risk type, and further processing should be handled accordingly.
        /// </summary>
        /// <param name="riskType"></param>
        /// <returns></returns>
        private bool ValidRiskType(string input)
        {
            _ = byte.TryParse(input, out byte risk);

            return
                ValidParameterValue(input) &&
                risk >= (byte)RiskType.Normal && risk <= (byte)RiskType.High;
        }

        /// <summary>
        /// This method generates an "OK" response containing a list of blood pressure readings (BPR). 
        /// It takes three parameters: 'personAge', 'noRequired', and 'riskType', representing age, quantity, 
        /// and risk type respectively. The method calls the 'CreateReadings' method with the given parameters 
        /// to generate a list of blood pressure readings based on specific age, risk type, and count 
        /// requirements. Finally, it returns a 'Response' object with the 'Status' and 'Data' properties set.
        /// </summary>
        /// <param name="personAge"></param>
        /// <param name="noRequired"></param>
        /// <param name="riskType"></param>
        /// <returns></returns>
        private Response GetOkResponse(byte personAge, byte noRequired, byte riskType)
        {
            List<BPR> readings = CreateReadings(personAge, noRequired, riskType);

            return GenerateResponse(200, "Ok", null, readings);

        }

        /// <summary>
        /// This method generates a bad response with a 400 status code (Bad Request) and an associated list 
        /// of errors based on specific input conditions. It takes three parameters: 'personAge', 'noRequired', 
        /// and 'riskType', which represent age, quantity, and risk type respectively. The method checks for 
        /// missing or invalid inputs and adds corresponding error messages to the 'errors' list. If the 
        /// 'riskType' parameter is not one of the defined values (1, 2, or 3) according to the 'RiskType' 
        /// enumeration, it adds an error message for invalid risk type. The method then creates a 'Status' 
        /// object containing the 400 status code, "Bad Request" status message, and the list of errors. 
        /// Finally, it returns a 'Response' object with the 'Status' and 'Data' properties set, where 'Data' 
        /// is set to null. This bad response is intended to communicate the presence of invalid or missing 
        /// parameters to the caller or consumer of the method.
        /// </summary>
        /// <param name="personAge"></param>
        /// <param name="noRequired"></param>
        /// <param name="riskType"></param>
        /// <returns></returns>
        private Response GetBadResponse(byte personAge, byte noRequired, byte riskType)
        {
            var errors = new List<string>();

            string ageMissing = personAge  == 0 ? "A valid value for parameter age is missing" : "";
            if (ageMissing.Length > 0) errors.Add(ageMissing);

            string qtyMissing = noRequired == 0 ? "A valid value for parameter quantity is missing" : "";
            if (qtyMissing.Length > 0) errors.Add(qtyMissing);

            string riskMissing = (riskType < 1 || riskType > 3) ? "A valid value for parameter risk is missing or incorrect. Valid values for risk are 1, 2, 3" : "";
            if (riskMissing.Length > 0) errors.Add(riskMissing);

            return GenerateResponse(400, "Bad Request", errors, null);

        }

        /// <summary>
        /// This function generates a custom response object based on the input parameters. It takes four 
        /// parameters: 'statusCode', 'statusMessage', 'errors', and 'data' (optional). The 'statusCode' and 
        /// 'statusMessage' parameters represent the HTTP status code and status message to be included in the 
        /// response. The 'errors' parameter is a list of strings that can hold any error messages or issues 
        /// encountered during response generation. The 'data' parameter (optional) represents a list of 
        /// blood pressure readings (BPR) to be included in the response payload. If the 'data' parameter is 
        /// not provided, it defaults to null.
        /// </summary>
        /// <param name="statusCode"></param>
        /// <param name="statusMessage"></param>
        /// <param name="errors"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        private Response GenerateResponse(ushort statusCode, string statusMessage, List<string> errors = null, List<BPR> data = null)
        {
            Status status = new Status
            {
                StatusCode = statusCode,
                StatusMessage = statusMessage,
                StatusErrors = errors
            };

            return new Response()
            {
                Status = status,
                Data = data
            };
        }

        /// <summary>
        /// This method generates a list of blood pressure readings (BPR) based on specific age, risk type, 
        /// and count requirements. It first retrieves the age-based pulse values from the 'CreateAgeToPulse' 
        /// method and selects the appropriate pulse value based on the 'personAge' parameter.
        /// Next, it fetches risk-based minimum and maximum values for systolic blood pressure (SYS) and 
        /// diastolic blood pressure (DIA) from 'CreateRiskToDia' and 'CreateRiskToSys' methods, respectively, 
        /// and selects the appropriate values based on the 'riskType' parameter.
        /// The method then generates 'noRequired' number of readings, each containing a random date and time 
        /// obtained using the 'GetRandomDateTime' method, as well as random SYS, DIA, and Pulse values within 
        /// the specified ranges. The generated readings are added to a list, which is returned as the final 
        /// result.
        /// </summary>
        /// <param name="personAge"></param>
        /// <param name="noRequired"></param>
        /// <param name="riskType"></param>
        /// <returns></returns>
        private List<BPR> CreateReadings(byte personAge, byte noRequired, byte riskType)
        {
            List<BPR> readings = new List<BPR>();

            List<AgeToPulse> ageToPulse = CreateAgeToPulse();

            // If the age is greater than 70 then use the 70+ values
            AgeToPulse atp = ageToPulse.Find(item => (item.Age >= personAge) || (item.Age == 70));

            List<RiskMinMax> riskMinMax = CreateRiskToDia();
            RiskMinMax rtd = riskMinMax.Find(item => item.Risk == riskType);

            riskMinMax = CreateRiskToSys();
            RiskMinMax rts = riskMinMax.Find(item => item.Risk == riskType);

            for (int i = 1; i<= noRequired; i += 1)
            {
                BPR bpr = new BPR();

                bpr.ReadingDate = GetRandomDateTime();
                bpr.SYS   = (byte)_random.Next(rts.Min, rts.Max);
                bpr.DIA   = (byte)_random.Next(rtd.Min, rtd.Max);
                bpr.Pulse = (byte)_random.Next(atp.Min, atp.Max);

                readings.Add(bpr);
            }

            return readings;
        }

        /// <summary>
        /// This method generates and returns a random DateTime value based on specific rules. 
        /// If the '_previousTime' variable is uninitialized (i.e., less than or equal to the default 
        /// value 'DateTime.MinValue'), it sets it to the current date using 'DateTime.Today' and then 
        /// calls 'SetNewDay()' to generate a new random time within the day. 
        /// If '_previousTime' has been previously set, it updates it to a new DateTime, which is 4 hours 
        /// ahead of the previous time.
        /// The method also keeps track of the number of readings using the '_readingCounter' variable. 
        /// After three iterations, it advances the date by one day and generates a new random time for 
        /// the beginning of the day, effectively simulating three readings per day. The final generated 
        /// DateTime is then returned.
        /// </summary>
        /// <returns></returns>
        private DateTime GetRandomDateTime()
        {
            // Checking _previousTime to see if it is the default value January 1, 0001, 00:00:00
            if (_previousTime <= default(DateTime))
            {
                // If no previous time
                _previousTime = DateTime.Today;
                _previousTime = SetNewDay();
            }
            else
            {
                // New time 4 hours after the previous time
                _previousTime = _previousTime.AddHours(4);
            }

            _readingCounter += 1;
            // After 3 iterations increase the day, three readings per day
            if (_readingCounter == 3)
            {
                _previousTime = _previousTime.AddDays(1);
                _previousTime = SetNewDay();
                _readingCounter = 0;
            }

            return _previousTime;
        }

        /// <summary>
        /// This method sets a new DateTime object representing a specific time within the current day.
        /// It uses the year, month, and day from the '_previousTime' DateTime object to ensure the new
        /// DateTime is within the same day. The hour is fixed at 10, and a random minute value between
        /// 0 and 58 is generated using the '_random' variable.
        /// </summary>
        /// <returns></returns>
        private DateTime SetNewDay()
        {
            // Ensure the '_previousTime' variable contains the correct date information.
            // If it's not properly set, this code might throw an exception.
            return new DateTime(_previousTime.Year, _previousTime.Month, _previousTime.Day, 10, _random.Next(0, 59), 0);
        }

        /// <summary>
        /// This method creates and returns a list of AgeToPulse objects, representing the relationship
        /// between different age groups and their corresponding pulse rate ranges. Each AgeToPulse object
        /// contains three properties: 'Age', 'Min', and 'Max'. The 'Age' property denotes the age group,
        /// while 'Min' and 'Max' represent the minimum and maximum pulse rates associated with that age group.
        /// The returned list provides a mapping of age groups to their respective pulse rate ranges.
        /// </summary>
        /// <returns></returns>
        private List<AgeToPulse> CreateAgeToPulse()
        {
            return new List<AgeToPulse>()
            {
                new AgeToPulse { Age = 20, Min = 99, Max = 200},
                new AgeToPulse { Age = 30, Min = 95, Max = 190},
                new AgeToPulse { Age = 35, Min = 93, Max = 185},
                new AgeToPulse { Age = 40, Min = 90, Max = 180},
                new AgeToPulse { Age = 45, Min = 88, Max = 175},
                new AgeToPulse { Age = 50, Min = 85, Max = 170},
                new AgeToPulse { Age = 55, Min = 83, Max = 165},
                new AgeToPulse { Age = 60, Min = 80, Max = 160},
                new AgeToPulse { Age = 65, Min = 78, Max = 155},
                new AgeToPulse { Age = 70, Min = 75, Max = 150},
            };
        }

        /// <summary>
        /// Creates and returns a list of RiskMinMax objects, representing different risk levels along
        /// with their corresponding minimum and maximum values. Each RiskMinMax object contains three
        /// properties: 'Risk', 'Min', and 'Max'. The 'Risk' property indicates the risk level (1, 2, or 3),
        /// while 'Min' and 'Max' represent the minimum and maximum values associated with that risk level.
        /// The returned list provides a mapping of diastolic pressure values to their risk ranges.
        /// </summary>
        /// <returns></returns>
        private List<RiskMinMax> CreateRiskToDia()
        {
            return new List<RiskMinMax>()
            {
                new RiskMinMax { Risk = 1, Min = 70, Max = 80},
                new RiskMinMax { Risk = 2, Min = 70, Max = 85},
                new RiskMinMax { Risk = 3, Min = 75, Max = 95},
            };
        }

        /// <summary>
        /// Creates and returns a list of RiskMinMax objects, representing different risk levels along
        /// with their corresponding minimum and maximum values. Each RiskMinMax object contains three
        /// properties: 'Risk', 'Min', and 'Max'. The 'Risk' property indicates the risk level (1, 2, or 3),
        /// while 'Min' and 'Max' represent the minimum and maximum values associated with that risk level.
        /// The returned list provides a mapping of systolic pressure values to their risk ranges.
        /// </summary>
        /// <returns></returns>
        private List<RiskMinMax> CreateRiskToSys()
        {
            return new List<RiskMinMax>()
            {
                new RiskMinMax { Risk = 1, Min =  90, Max = 120},
                new RiskMinMax { Risk = 2, Min = 120, Max = 145},
                new RiskMinMax { Risk = 3, Min = 140, Max = 190},
            };
        }

    }
}
